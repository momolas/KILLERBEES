// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: arsdk/network.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Routing policy. 
enum Arsdk_Network_RoutingPolicy: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Broadcast to all links. 
  case all // = 0

  /// Use Wlan link if available, otherwise broadcast. 
  case wlan // = 1

  /// Use Cellular link if available, otherwise broadcast. 
  case cellular // = 2

  /// Select best link. 
  case hybrid // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .all
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .all
    case 1: self = .wlan
    case 2: self = .cellular
    case 3: self = .hybrid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .all: return 0
    case .wlan: return 1
    case .cellular: return 2
    case .hybrid: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Network_RoutingPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Network_RoutingPolicy] = [
    .all,
    .wlan,
    .cellular,
    .hybrid,
  ]
}

#endif  // swift(>=4.2)

/// Routing link. 
enum Arsdk_Network_RoutingLink: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Unspecified link. 
  case any // = 0

  /// Wlan link. 
  case wlan // = 1

  /// Cellular link. 
  case cellular // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .any
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .any
    case 1: self = .wlan
    case 2: self = .cellular
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .any: return 0
    case .wlan: return 1
    case .cellular: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Network_RoutingLink: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Network_RoutingLink] = [
    .any,
    .wlan,
    .cellular,
  ]
}

#endif  // swift(>=4.2)

/// Link status. 
enum Arsdk_Network_LinkStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Interface is down. 
  case down // = 0

  /// Interface is up with IP connectivity. 
  case up // = 1

  /// Starfish session established on the link. 
  case running // = 2

  /// Link is ready to connect or accept connections. 
  case ready // = 3

  /// Connection in progress. 
  case connecting // = 4

  /// Link error, see LinkError value. 
  case error // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .down
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .down
    case 1: self = .up
    case 2: self = .running
    case 3: self = .ready
    case 4: self = .connecting
    case 5: self = .error
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .down: return 0
    case .up: return 1
    case .running: return 2
    case .ready: return 3
    case .connecting: return 4
    case .error: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Network_LinkStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Network_LinkStatus] = [
    .down,
    .up,
    .running,
    .ready,
    .connecting,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// Link type. 
enum Arsdk_Network_LinkType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Unknown. 
  case unknown // = 0

  /// Reserved. 
  case lo // = 1

  /// Reserved. 
  case lan // = 2

  /// Wlan (Wi-Fi) interface. 
  case wlan // = 3

  /// Cellular (4G) interface. 
  case cellular // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .lo
    case 2: self = .lan
    case 3: self = .wlan
    case 4: self = .cellular
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .lo: return 1
    case .lan: return 2
    case .wlan: return 3
    case .cellular: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Network_LinkType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Network_LinkType] = [
    .unknown,
    .lo,
    .lan,
    .wlan,
    .cellular,
  ]
}

#endif  // swift(>=4.2)

/// Link error. 
enum Arsdk_Network_LinkError: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// No error. 
  case none // = 0

  /// Failed to resolve DNS address. 
  case dns // = 1

  /// Failed to connect to SIP server. 
  case connect // = 2

  /// Failed to authenticate to server. 
  case authentication // = 3

  /// Failed to publish drone status. 
  case publish // = 4

  /// Failed to establish communication link. 
  case commLink // = 5

  /// Lost connection with peer. 
  case timeout // = 6

  /// Failed to invite drone. 
  case invite // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .dns
    case 2: self = .connect
    case 3: self = .authentication
    case 4: self = .publish
    case 5: self = .commLink
    case 6: self = .timeout
    case 7: self = .invite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .dns: return 1
    case .connect: return 2
    case .authentication: return 3
    case .publish: return 4
    case .commLink: return 5
    case .timeout: return 6
    case .invite: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Network_LinkError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Network_LinkError] = [
    .none,
    .dns,
    .connect,
    .authentication,
    .publish,
    .commLink,
    .timeout,
    .invite,
  ]
}

#endif  // swift(>=4.2)

/// Direct connection mode 
enum Arsdk_Network_DirectConnectionMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Legacy mode: secure connection is not mandatory. 
  case legacy // = 0

  /// Only secure connections are authorized. 
  case secure // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .legacy
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .legacy
    case 1: self = .secure
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .legacy: return 0
    case .secure: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Network_DirectConnectionMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Network_DirectConnectionMode] = [
    .legacy,
    .secure,
  ]
}

#endif  // swift(>=4.2)

/// Cellular status 
enum Arsdk_Network_CellularStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0

  /// Modem status. 
  case modemOff // = 1
  case modemOffline // = 2
  case modemFlashing // = 3
  case modemOnline // = 4
  case modemError // = 5

  /// SIM status. 
  case simLocked // = 6
  case simReady // = 7
  case simAbsent // = 8
  case simError // = 9

  /// Network registration status. 
  case networkSearching // = 10
  case networkHome // = 11
  case networkRoaming // = 12
  case networkRegistrationDenied // = 13
  case networkActivationDenied // = 14

  /// Parrot server connection status. 
  case serverWaitApcToken // = 15
  case serverConnecting // = 16
  case serverConnected // = 17
  case serverUnreachableDns // = 18
  case serverUnreachableConnect // = 19
  case serverUnreachableAuth // = 20

  /// Drone/controller connection status. 
  case connectionOffline // = 21
  case connectionConnecting // = 22
  case connectionEstablished // = 23
  case connectionError // = 24
  case connectionErrorCommLink // = 25
  case connectionErrorTimeout // = 26
  case connectionErrorMismatch // = 27
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .modemOff
    case 2: self = .modemOffline
    case 3: self = .modemFlashing
    case 4: self = .modemOnline
    case 5: self = .modemError
    case 6: self = .simLocked
    case 7: self = .simReady
    case 8: self = .simAbsent
    case 9: self = .simError
    case 10: self = .networkSearching
    case 11: self = .networkHome
    case 12: self = .networkRoaming
    case 13: self = .networkRegistrationDenied
    case 14: self = .networkActivationDenied
    case 15: self = .serverWaitApcToken
    case 16: self = .serverConnecting
    case 17: self = .serverConnected
    case 18: self = .serverUnreachableDns
    case 19: self = .serverUnreachableConnect
    case 20: self = .serverUnreachableAuth
    case 21: self = .connectionOffline
    case 22: self = .connectionConnecting
    case 23: self = .connectionEstablished
    case 24: self = .connectionError
    case 25: self = .connectionErrorCommLink
    case 26: self = .connectionErrorTimeout
    case 27: self = .connectionErrorMismatch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .modemOff: return 1
    case .modemOffline: return 2
    case .modemFlashing: return 3
    case .modemOnline: return 4
    case .modemError: return 5
    case .simLocked: return 6
    case .simReady: return 7
    case .simAbsent: return 8
    case .simError: return 9
    case .networkSearching: return 10
    case .networkHome: return 11
    case .networkRoaming: return 12
    case .networkRegistrationDenied: return 13
    case .networkActivationDenied: return 14
    case .serverWaitApcToken: return 15
    case .serverConnecting: return 16
    case .serverConnected: return 17
    case .serverUnreachableDns: return 18
    case .serverUnreachableConnect: return 19
    case .serverUnreachableAuth: return 20
    case .connectionOffline: return 21
    case .connectionConnecting: return 22
    case .connectionEstablished: return 23
    case .connectionError: return 24
    case .connectionErrorCommLink: return 25
    case .connectionErrorTimeout: return 26
    case .connectionErrorMismatch: return 27
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Network_CellularStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Network_CellularStatus] = [
    .unknown,
    .modemOff,
    .modemOffline,
    .modemFlashing,
    .modemOnline,
    .modemError,
    .simLocked,
    .simReady,
    .simAbsent,
    .simError,
    .networkSearching,
    .networkHome,
    .networkRoaming,
    .networkRegistrationDenied,
    .networkActivationDenied,
    .serverWaitApcToken,
    .serverConnecting,
    .serverConnected,
    .serverUnreachableDns,
    .serverUnreachableConnect,
    .serverUnreachableAuth,
    .connectionOffline,
    .connectionConnecting,
    .connectionEstablished,
    .connectionError,
    .connectionErrorCommLink,
    .connectionErrorTimeout,
    .connectionErrorMismatch,
  ]
}

#endif  // swift(>=4.2)

/// This is the entry point to send messages to the drone. 
struct Arsdk_Network_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Arsdk_Network_Command.OneOf_ID? = nil

  var getState: Arsdk_Network_Command.GetState {
    get {
      if case .getState(let v)? = id {return v}
      return Arsdk_Network_Command.GetState()
    }
    set {id = .getState(newValue)}
  }

  var setRoutingPolicy: Arsdk_Network_Command.SetRoutingPolicy {
    get {
      if case .setRoutingPolicy(let v)? = id {return v}
      return Arsdk_Network_Command.SetRoutingPolicy()
    }
    set {id = .setRoutingPolicy(newValue)}
  }

  var setCellularMaxBitrate: Arsdk_Network_Command.SetCellularMaxBitrate {
    get {
      if case .setCellularMaxBitrate(let v)? = id {return v}
      return Arsdk_Network_Command.SetCellularMaxBitrate()
    }
    set {id = .setCellularMaxBitrate(newValue)}
  }

  var setDirectConnection: Arsdk_Network_Command.SetDirectConnection {
    get {
      if case .setDirectConnection(let v)? = id {return v}
      return Arsdk_Network_Command.SetDirectConnection()
    }
    set {id = .setDirectConnection(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case getState(Arsdk_Network_Command.GetState)
    case setRoutingPolicy(Arsdk_Network_Command.SetRoutingPolicy)
    case setCellularMaxBitrate(Arsdk_Network_Command.SetCellularMaxBitrate)
    case setDirectConnection(Arsdk_Network_Command.SetDirectConnection)

  #if !swift(>=4.1)
    static func ==(lhs: Arsdk_Network_Command.OneOf_ID, rhs: Arsdk_Network_Command.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getState, .getState): return {
        guard case .getState(let l) = lhs, case .getState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setRoutingPolicy, .setRoutingPolicy): return {
        guard case .setRoutingPolicy(let l) = lhs, case .setRoutingPolicy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setCellularMaxBitrate, .setCellularMaxBitrate): return {
        guard case .setCellularMaxBitrate(let l) = lhs, case .setCellularMaxBitrate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setDirectConnection, .setDirectConnection): return {
        guard case .setDirectConnection(let l) = lhs, case .setDirectConnection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Get current state. 
  struct GetState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Include default_capabilities in response. 
    var includeDefaultCapabilities: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Set routing policy. 
  struct SetRoutingPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Routing policy. 
    var policy: Arsdk_Network_RoutingPolicy = .all

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Change Cellular Max bitrate. 
  struct SetCellularMaxBitrate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Maximum bitrate in Kbps (0 for default value) 
    var maxBitrate: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Set direct connection mode
  /// State is sent afterwards. 
  struct SetDirectConnection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mode: Arsdk_Network_DirectConnectionMode = .legacy

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// This is the entry point to receive messages from the drone. 
struct Arsdk_Network_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Arsdk_Network_Event.OneOf_ID? = nil

  var state: Arsdk_Network_Event.State {
    get {
      if case .state(let v)? = id {return v}
      return Arsdk_Network_Event.State()
    }
    set {id = .state(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case state(Arsdk_Network_Event.State)

  #if !swift(>=4.1)
    static func ==(lhs: Arsdk_Network_Event.OneOf_ID, rhs: Arsdk_Network_Event.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.state, .state): return {
        guard case .state(let l) = lhs, case .state(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Current state. 
  struct State {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var defaultCapabilities: Arsdk_Network_Capabilities {
      get {return _defaultCapabilities ?? Arsdk_Network_Capabilities()}
      set {_defaultCapabilities = newValue}
    }
    /// Returns true if `defaultCapabilities` has been explicitly set.
    var hasDefaultCapabilities: Bool {return self._defaultCapabilities != nil}
    /// Clears the value of `defaultCapabilities`. Subsequent reads from it will return its default value.
    mutating func clearDefaultCapabilities() {self._defaultCapabilities = nil}

    var routingInfo: Arsdk_Network_RoutingInfo {
      get {return _routingInfo ?? Arsdk_Network_RoutingInfo()}
      set {_routingInfo = newValue}
    }
    /// Returns true if `routingInfo` has been explicitly set.
    var hasRoutingInfo: Bool {return self._routingInfo != nil}
    /// Clears the value of `routingInfo`. Subsequent reads from it will return its default value.
    mutating func clearRoutingInfo() {self._routingInfo = nil}

    var globalLinkQuality: Arsdk_Network_GlobalLinkQuality {
      get {return _globalLinkQuality ?? Arsdk_Network_GlobalLinkQuality()}
      set {_globalLinkQuality = newValue}
    }
    /// Returns true if `globalLinkQuality` has been explicitly set.
    var hasGlobalLinkQuality: Bool {return self._globalLinkQuality != nil}
    /// Clears the value of `globalLinkQuality`. Subsequent reads from it will return its default value.
    mutating func clearGlobalLinkQuality() {self._globalLinkQuality = nil}

    var linksStatus: Arsdk_Network_LinksStatus {
      get {return _linksStatus ?? Arsdk_Network_LinksStatus()}
      set {_linksStatus = newValue}
    }
    /// Returns true if `linksStatus` has been explicitly set.
    var hasLinksStatus: Bool {return self._linksStatus != nil}
    /// Clears the value of `linksStatus`. Subsequent reads from it will return its default value.
    mutating func clearLinksStatus() {self._linksStatus = nil}

    var cellularMaxBitrate: Arsdk_Network_CellularMaxBitrate {
      get {return _cellularMaxBitrate ?? Arsdk_Network_CellularMaxBitrate()}
      set {_cellularMaxBitrate = newValue}
    }
    /// Returns true if `cellularMaxBitrate` has been explicitly set.
    var hasCellularMaxBitrate: Bool {return self._cellularMaxBitrate != nil}
    /// Clears the value of `cellularMaxBitrate`. Subsequent reads from it will return its default value.
    mutating func clearCellularMaxBitrate() {self._cellularMaxBitrate = nil}

    var directConnectionMode: Arsdk_Network_DirectConnectionMode = .legacy

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _defaultCapabilities: Arsdk_Network_Capabilities? = nil
    fileprivate var _routingInfo: Arsdk_Network_RoutingInfo? = nil
    fileprivate var _globalLinkQuality: Arsdk_Network_GlobalLinkQuality? = nil
    fileprivate var _linksStatus: Arsdk_Network_LinksStatus? = nil
    fileprivate var _cellularMaxBitrate: Arsdk_Network_CellularMaxBitrate? = nil
  }

  init() {}
}

/// Capabilities. 
struct Arsdk_Network_Capabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum bitrate of cellular link in Kbps. 
  var cellularMinBitrate: Int32 = 0

  /// Maximum bitrate of cellular link in Kbps. 
  var cellularMaxBitrate: Int32 = 0

  /// DirectConnectionMode supported 
  var supportedDirectConnectionModes: [Arsdk_Network_DirectConnectionMode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Routing information. 
struct Arsdk_Network_RoutingInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Routing policy. 
  var policy: Arsdk_Network_RoutingPolicy = .all

  /// Current selected link. 
  var currentLink: Arsdk_Network_RoutingLink = .any

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Global link quality. 
struct Arsdk_Network_GlobalLinkQuality {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Link quality indication: 1 (lower) to 5 (better),
  /// 0 if not available. 
  var quality: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Links status. 
struct Arsdk_Network_LinksStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var links: [Arsdk_Network_LinksStatus.LinkInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct LinkInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Type of link. 
    var type: Arsdk_Network_LinkType = .unknown

    /// Link status. 
    var status: Arsdk_Network_LinkStatus = .down

    /// Link quality indication. (see GlobalLinkQuality) 
    var quality: Int32 = 0

    /// Link error. 
    var error: Arsdk_Network_LinkError = .none

    /// Extended status of cellular links. 
    var cellularStatus: Arsdk_Network_CellularStatus = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Cellular Max bitrate. 
struct Arsdk_Network_CellularMaxBitrate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum bitrate in Kbps. (0 for default value) 
  var maxBitrate: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Arsdk_Network_RoutingPolicy: @unchecked Sendable {}
extension Arsdk_Network_RoutingLink: @unchecked Sendable {}
extension Arsdk_Network_LinkStatus: @unchecked Sendable {}
extension Arsdk_Network_LinkType: @unchecked Sendable {}
extension Arsdk_Network_LinkError: @unchecked Sendable {}
extension Arsdk_Network_DirectConnectionMode: @unchecked Sendable {}
extension Arsdk_Network_CellularStatus: @unchecked Sendable {}
extension Arsdk_Network_Command: @unchecked Sendable {}
extension Arsdk_Network_Command.OneOf_ID: @unchecked Sendable {}
extension Arsdk_Network_Command.GetState: @unchecked Sendable {}
extension Arsdk_Network_Command.SetRoutingPolicy: @unchecked Sendable {}
extension Arsdk_Network_Command.SetCellularMaxBitrate: @unchecked Sendable {}
extension Arsdk_Network_Command.SetDirectConnection: @unchecked Sendable {}
extension Arsdk_Network_Event: @unchecked Sendable {}
extension Arsdk_Network_Event.OneOf_ID: @unchecked Sendable {}
extension Arsdk_Network_Event.State: @unchecked Sendable {}
extension Arsdk_Network_Capabilities: @unchecked Sendable {}
extension Arsdk_Network_RoutingInfo: @unchecked Sendable {}
extension Arsdk_Network_GlobalLinkQuality: @unchecked Sendable {}
extension Arsdk_Network_LinksStatus: @unchecked Sendable {}
extension Arsdk_Network_LinksStatus.LinkInfo: @unchecked Sendable {}
extension Arsdk_Network_CellularMaxBitrate: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "arsdk.network"

extension Arsdk_Network_RoutingPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROUTING_POLICY_ALL"),
    1: .same(proto: "ROUTING_POLICY_WLAN"),
    2: .same(proto: "ROUTING_POLICY_CELLULAR"),
    3: .same(proto: "ROUTING_POLICY_HYBRID"),
  ]
}

extension Arsdk_Network_RoutingLink: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROUTING_LINK_ANY"),
    1: .same(proto: "ROUTING_LINK_WLAN"),
    2: .same(proto: "ROUTING_LINK_CELLULAR"),
  ]
}

extension Arsdk_Network_LinkStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LINK_STATUS_DOWN"),
    1: .same(proto: "LINK_STATUS_UP"),
    2: .same(proto: "LINK_STATUS_RUNNING"),
    3: .same(proto: "LINK_STATUS_READY"),
    4: .same(proto: "LINK_STATUS_CONNECTING"),
    5: .same(proto: "LINK_STATUS_ERROR"),
  ]
}

extension Arsdk_Network_LinkType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LINK_TYPE_UNKNOWN"),
    1: .same(proto: "LINK_TYPE_LO"),
    2: .same(proto: "LINK_TYPE_LAN"),
    3: .same(proto: "LINK_TYPE_WLAN"),
    4: .same(proto: "LINK_TYPE_CELLULAR"),
  ]
}

extension Arsdk_Network_LinkError: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LINK_ERROR_NONE"),
    1: .same(proto: "LINK_ERROR_DNS"),
    2: .same(proto: "LINK_ERROR_CONNECT"),
    3: .same(proto: "LINK_ERROR_AUTHENTICATION"),
    4: .same(proto: "LINK_ERROR_PUBLISH"),
    5: .same(proto: "LINK_ERROR_COMM_LINK"),
    6: .same(proto: "LINK_ERROR_TIMEOUT"),
    7: .same(proto: "LINK_ERROR_INVITE"),
  ]
}

extension Arsdk_Network_DirectConnectionMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECT_CONNECTION_MODE_LEGACY"),
    1: .same(proto: "DIRECT_CONNECTION_MODE_SECURE"),
  ]
}

extension Arsdk_Network_CellularStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CELLULAR_STATUS_UNKNOWN"),
    1: .same(proto: "CELLULAR_STATUS_MODEM_OFF"),
    2: .same(proto: "CELLULAR_STATUS_MODEM_OFFLINE"),
    3: .same(proto: "CELLULAR_STATUS_MODEM_FLASHING"),
    4: .same(proto: "CELLULAR_STATUS_MODEM_ONLINE"),
    5: .same(proto: "CELLULAR_STATUS_MODEM_ERROR"),
    6: .same(proto: "CELLULAR_STATUS_SIM_LOCKED"),
    7: .same(proto: "CELLULAR_STATUS_SIM_READY"),
    8: .same(proto: "CELLULAR_STATUS_SIM_ABSENT"),
    9: .same(proto: "CELLULAR_STATUS_SIM_ERROR"),
    10: .same(proto: "CELLULAR_STATUS_NETWORK_SEARCHING"),
    11: .same(proto: "CELLULAR_STATUS_NETWORK_HOME"),
    12: .same(proto: "CELLULAR_STATUS_NETWORK_ROAMING"),
    13: .same(proto: "CELLULAR_STATUS_NETWORK_REGISTRATION_DENIED"),
    14: .same(proto: "CELLULAR_STATUS_NETWORK_ACTIVATION_DENIED"),
    15: .same(proto: "CELLULAR_STATUS_SERVER_WAIT_APC_TOKEN"),
    16: .same(proto: "CELLULAR_STATUS_SERVER_CONNECTING"),
    17: .same(proto: "CELLULAR_STATUS_SERVER_CONNECTED"),
    18: .same(proto: "CELLULAR_STATUS_SERVER_UNREACHABLE_DNS"),
    19: .same(proto: "CELLULAR_STATUS_SERVER_UNREACHABLE_CONNECT"),
    20: .same(proto: "CELLULAR_STATUS_SERVER_UNREACHABLE_AUTH"),
    21: .same(proto: "CELLULAR_STATUS_CONNECTION_OFFLINE"),
    22: .same(proto: "CELLULAR_STATUS_CONNECTION_CONNECTING"),
    23: .same(proto: "CELLULAR_STATUS_CONNECTION_ESTABLISHED"),
    24: .same(proto: "CELLULAR_STATUS_CONNECTION_ERROR"),
    25: .same(proto: "CELLULAR_STATUS_CONNECTION_ERROR_COMM_LINK"),
    26: .same(proto: "CELLULAR_STATUS_CONNECTION_ERROR_TIMEOUT"),
    27: .same(proto: "CELLULAR_STATUS_CONNECTION_ERROR_MISMATCH"),
  ]
}

extension Arsdk_Network_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    16: .standard(proto: "get_state"),
    17: .standard(proto: "set_routing_policy"),
    18: .standard(proto: "set_cellular_max_bitrate"),
    19: .standard(proto: "set_direct_connection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 16: try {
        var v: Arsdk_Network_Command.GetState?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .getState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .getState(v)
        }
      }()
      case 17: try {
        var v: Arsdk_Network_Command.SetRoutingPolicy?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .setRoutingPolicy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .setRoutingPolicy(v)
        }
      }()
      case 18: try {
        var v: Arsdk_Network_Command.SetCellularMaxBitrate?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .setCellularMaxBitrate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .setCellularMaxBitrate(v)
        }
      }()
      case 19: try {
        var v: Arsdk_Network_Command.SetDirectConnection?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .setDirectConnection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .setDirectConnection(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .getState?: try {
      guard case .getState(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .setRoutingPolicy?: try {
      guard case .setRoutingPolicy(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .setCellularMaxBitrate?: try {
      guard case .setCellularMaxBitrate(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .setDirectConnection?: try {
      guard case .setDirectConnection(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_Command, rhs: Arsdk_Network_Command) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_Command.GetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Network_Command.protoMessageName + ".GetState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "include_default_capabilities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeDefaultCapabilities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeDefaultCapabilities != false {
      try visitor.visitSingularBoolField(value: self.includeDefaultCapabilities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_Command.GetState, rhs: Arsdk_Network_Command.GetState) -> Bool {
    if lhs.includeDefaultCapabilities != rhs.includeDefaultCapabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_Command.SetRoutingPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Network_Command.protoMessageName + ".SetRoutingPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.policy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.policy != .all {
      try visitor.visitSingularEnumField(value: self.policy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_Command.SetRoutingPolicy, rhs: Arsdk_Network_Command.SetRoutingPolicy) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_Command.SetCellularMaxBitrate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Network_Command.protoMessageName + ".SetCellularMaxBitrate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_bitrate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.maxBitrate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxBitrate != 0 {
      try visitor.visitSingularInt32Field(value: self.maxBitrate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_Command.SetCellularMaxBitrate, rhs: Arsdk_Network_Command.SetCellularMaxBitrate) -> Bool {
    if lhs.maxBitrate != rhs.maxBitrate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_Command.SetDirectConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Network_Command.protoMessageName + ".SetDirectConnection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .legacy {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_Command.SetDirectConnection, rhs: Arsdk_Network_Command.SetDirectConnection) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    19: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 19: try {
        var v: Arsdk_Network_Event.State?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .state(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .state(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .state(let v)? = self.id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_Event, rhs: Arsdk_Network_Event) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_Event.State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Network_Event.protoMessageName + ".State"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_capabilities"),
    2: .standard(proto: "routing_info"),
    3: .standard(proto: "global_link_quality"),
    4: .standard(proto: "links_status"),
    5: .standard(proto: "cellular_max_bitrate"),
    6: .standard(proto: "direct_connection_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._defaultCapabilities) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._routingInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._globalLinkQuality) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._linksStatus) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cellularMaxBitrate) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.directConnectionMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._defaultCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._routingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._globalLinkQuality {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._linksStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._cellularMaxBitrate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.directConnectionMode != .legacy {
      try visitor.visitSingularEnumField(value: self.directConnectionMode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_Event.State, rhs: Arsdk_Network_Event.State) -> Bool {
    if lhs._defaultCapabilities != rhs._defaultCapabilities {return false}
    if lhs._routingInfo != rhs._routingInfo {return false}
    if lhs._globalLinkQuality != rhs._globalLinkQuality {return false}
    if lhs._linksStatus != rhs._linksStatus {return false}
    if lhs._cellularMaxBitrate != rhs._cellularMaxBitrate {return false}
    if lhs.directConnectionMode != rhs.directConnectionMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Capabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cellular_min_bitrate"),
    2: .standard(proto: "cellular_max_bitrate"),
    3: .standard(proto: "supported_direct_connection_modes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.cellularMinBitrate) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.cellularMaxBitrate) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.supportedDirectConnectionModes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cellularMinBitrate != 0 {
      try visitor.visitSingularInt32Field(value: self.cellularMinBitrate, fieldNumber: 1)
    }
    if self.cellularMaxBitrate != 0 {
      try visitor.visitSingularInt32Field(value: self.cellularMaxBitrate, fieldNumber: 2)
    }
    if !self.supportedDirectConnectionModes.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportedDirectConnectionModes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_Capabilities, rhs: Arsdk_Network_Capabilities) -> Bool {
    if lhs.cellularMinBitrate != rhs.cellularMinBitrate {return false}
    if lhs.cellularMaxBitrate != rhs.cellularMaxBitrate {return false}
    if lhs.supportedDirectConnectionModes != rhs.supportedDirectConnectionModes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_RoutingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoutingInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policy"),
    2: .standard(proto: "current_link"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.policy) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.currentLink) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.policy != .all {
      try visitor.visitSingularEnumField(value: self.policy, fieldNumber: 1)
    }
    if self.currentLink != .any {
      try visitor.visitSingularEnumField(value: self.currentLink, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_RoutingInfo, rhs: Arsdk_Network_RoutingInfo) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs.currentLink != rhs.currentLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_GlobalLinkQuality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GlobalLinkQuality"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quality"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.quality) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.quality != 0 {
      try visitor.visitSingularInt32Field(value: self.quality, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_GlobalLinkQuality, rhs: Arsdk_Network_GlobalLinkQuality) -> Bool {
    if lhs.quality != rhs.quality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_LinksStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinksStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "links"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_LinksStatus, rhs: Arsdk_Network_LinksStatus) -> Bool {
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_LinksStatus.LinkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Network_LinksStatus.protoMessageName + ".LinkInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "quality"),
    4: .same(proto: "error"),
    5: .standard(proto: "cellular_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.quality) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.cellularStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.status != .down {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.quality != 0 {
      try visitor.visitSingularInt32Field(value: self.quality, fieldNumber: 3)
    }
    if self.error != .none {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 4)
    }
    if self.cellularStatus != .unknown {
      try visitor.visitSingularEnumField(value: self.cellularStatus, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_LinksStatus.LinkInfo, rhs: Arsdk_Network_LinksStatus.LinkInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.status != rhs.status {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.error != rhs.error {return false}
    if lhs.cellularStatus != rhs.cellularStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Network_CellularMaxBitrate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellularMaxBitrate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_bitrate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.maxBitrate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxBitrate != 0 {
      try visitor.visitSingularInt32Field(value: self.maxBitrate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Network_CellularMaxBitrate, rhs: Arsdk_Network_CellularMaxBitrate) -> Bool {
    if lhs.maxBitrate != rhs.maxBitrate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
